#include <stdio.h>
#include <math.h>
#include "libs/matrixIO.cpp"
// можно просто скопировать исходный код в этот файл, если напрягает использование библиотек

/*
Приводит матрицу к треугольному виду и рассчитывает ранг матрицы

Почему не используются станадртные операции с матрицами из matrixOp.cpp?
Потому что для гаусса нам не нужны операции со всей строкой, нам нужна операция
только с той частью строки, которая еще не была обработана предыдущими проходами 
(это может сильно влиять на производительность в больших матрицах).

К тому же, это позволяет убрать на месте ошибки округления и предотвратить
появление -0.0000 в выводе.

Написано 18.04.20 Акостеловым И.И.
Рефакторинг 29.08.20
*/

const double EPS = 1e-8;

int gauss(double *matr, int m, int n);
void swap(double *a, double *b);

int main()
{
    int m, n;
    double *matr; 
    // matr - это массив, поэтому задается как указатель
    // адресация не как matr[i][j], а как matr[i*n+j]
    if (!readMatrix("input.txt", &matr, &m, &n))
    {
        perror("Cannot read");
        return (-1);
    }

    int rank = gauss(matr, m, n);

    if (!writeMatrix("output.txt", matr, m, n))
    {
        perror("Cannot write");
        return (-1);
    }

    printf("Matrix rank is %d\n", rank);
}

int gauss(double *matr, int m, int n)
{
    int i = 0; // текущая строка
    int j = 0; // текущий столбец

    // ищем максимумальный ненулевой элемент в j-м столбце, начиная с i-ой строки
    // (при этом j и i на каждом проходе сдвигаются по диагонали вперед),
    // затем обнуляем столбец - и так всю матрицу, до приведения к треугольному виду
    while (i < m && j < n)
    {
        double maxElem = (-1.); // наибольший элемент (по модулю) в столбце
        int maxElemRow = m; // номер строки этого элемента

        // находим наибольший элемент в столбце и его позицию
        for (int k = i; k < m; ++k)
        {
            if (abs(matr[k * n + j]) > maxElem)
            {
                maxElem = abs(matr[k * n + j]);
                maxElemRow = k;
            }
        }

        // если столбец оказался нулевым и максимальный элемент меньше погрешности
        if (maxElem <= EPS)
        {
            // окончательно обнуляем его
            for (int k = i; k < m; ++k)
                matr[k * n + j] = 0.;

            // переходим к следующему столбцу
            ++j;
            continue;
        }

        // если максимальный элемент находится не на диагонали, перемещаем его туда, меняя строки местами
        if (maxElemRow != i)
        {
            for (int k = j; k < n; ++k)
            {
                swap(&matr[i*n+k], &matr[maxElemRow*n+k]);
            }
        }

        // обнуляем j-ый столбец начиная с i+1 строки
        for (int k = i + 1; k < m; ++k)
        {
            // во сколько раз текущий элемент меньше наибольшего
            double lambda = matr[k * n + j] / matr[i * n + j];

            // вычитаем из всей строки 'излишек' (третье элементарное преобразование)
            for (int l = j + 1; l < n; ++l)
                matr[k * n + l] -= lambda * matr[i * n + l];

            // для избежания ошибок округления обнуляем значение в текущем столбце вручную
            matr[k * n + j] = 0.;
        }

        ++i; ++j;
    }
    
    // ранг равен числу строк
    return i;
}

// поменять местами переменные a и b с сохранением знака определителя 
void swap(double *a, double *b)
{
    double tmp = *a;
    *a = *b;
    *b = (-1)*tmp;
}