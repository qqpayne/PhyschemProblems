#include <stdio.h>
#include <math.h>

/*
Эта программа вычисляет арктангенс используя разложение в ряд, замену переменной и тригонометрические соотношения

Этот вариант программы использует соотношение arctg(y) = pi/2 - arctg(1/y) для значений y > 50
Также, используется то, что arctg(y) = -arctg(-y) 
При значениях y <= 50 он использует замену переменной в арктангенсе из прошлой программы
При таком подходе дойти до значения y, меньшего 0.02 можно за 12 шагов при самом плохом вводе
Почему 0.02? При y<=0.02 нам нужно будет посчитать только первые 4 члена ряда для точности в 1e-12

Итого, при 0<y<50 мы имеем O(log(n)), при y>50 - O(1)
Согласно тестам, работает примерно в 5 раз быстрее старой версии

Написано в конце 2019 Акостеловым И.И.
Рефакторинг 28.08.20
*/

const double EPS = 1e-12;
double arctgSeries(double x);

int main()
{
	double x, res;

	while (true)
	{
		printf("x: ");
		if (scanf("%lg", &x) < 1)
			break;

		double xBackup = x;

		// abs(x) для работы с отрицательными числаим
		if (abs(x) > 50)
			res = (M_PI / 2) - arctgSeries(1 / x);
		else
		{
			// итерации с заменой переменных
			int numOfChanges = 0;
			while (abs(x) > 0.02)
			{
				x = (x / (1 + sqrt(1 + x * x)));
				++numOfChanges;
			}
			// 1 << n сдвигает бит n раз влево, что равноценно возведению 2 в n-ую степень, но работает быстрее
			res = arctgSeries(x) * (1 << numOfChanges);
		}

		printf("arctg(x) = %.14f\n", res);
		printf("lib arctg(x) = %.14f\n", atan(xBackup));
	}
	return 0;
}

double arctgSeries(double x)
{
	// ряд тейлора для арктангенса
	double term = x, sum = x, prev = x; // начинаем с первого члена - x
	int n = 1;
	while (abs(term) > EPS)
	{
		// каждый следующий член ряда получается из предыдущего 
		// домножением на x^2, сменой знака и заменой n в знаменателе на n + 2 
		term = (-1) * ((prev * x * x * n) / (n + 2));
		sum += term;
		prev = term;
		n += 2;
	}
	return sum;
}
